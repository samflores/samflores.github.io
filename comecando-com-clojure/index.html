<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Come√ßando com Clojure</title>
    <meta name="description" content="H√° mais ou menos dois anos eu resolvi me aprofundar no estudo de linguagens deprograma√ß√£o funcionais. Entre as candidatas estavam Scala, Erlang, Haskele Cloj...">

    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Goudy+Bookletter+1911|Anonymous+Pro">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="http://blog.samflor.es/comecando-com-clojure">
    <link rel="alternate" type="application/rss+xml" title="Sparse Thoughts" href="http://blog.samflor.es/feed.xml" />
</head>


<body>
    <article class="post">
    <h1><a href="/"><span>Sparse Thoughts</span></a>Come√ßando com Clojure</h1>
    <aside>
        <time datetime="2015-09-07 21:50">
            Sep 7, 2015
        </time>
        
        
    </aside>
    <p>H√° mais ou menos dois anos eu resolvi me aprofundar no estudo de <em>linguagens de
programa√ß√£o funcionais</em>. Entre as candidatas estavam <em>Scala</em>, <em>Erlang</em>, <em>Haskel</em>
e <em>Clojure</em>.</p>

<p>Clojure estava em √∫ltimo lugar na minha lista de interesses devido √†
experi√™ncias anteriores n√£o muito agrad√°veis com outros <em>Lisps</em>, mas depois de
ler uma cita√ß√£o do <em>Richard Stallman</em> achei que deveria tentar de novo (n√£o que
eu costume concordar com ele, mas fiquei curioso):</p>

<blockquote>
  <p>The most powerful programming language is Lisp. If you don‚Äôt know Lisp (or its
variant, Scheme), you don‚Äôt know what it means for a programming language to
be powerful and elegant. Once you learn Lisp, you will understand what is
lacking in most other languages.</p>
</blockquote>

<h2 id="o-que--clojure">O que √© Clojure?</h2>

<p>Clojure √© um <em>Lisp</em> (eu sei que j√° deu pra entender isso) e compartilha
caracter√≠sticas comuns √† maioria deles, ou seja, Clojure √© uma linguagem:</p>

<ul>
  <li>primariamente funcional;</li>
  <li>din√¢mica;</li>
  <li>fortemente tipada;</li>
  <li>homoic√¥nica;</li>
</ul>

<p>Al√©m de ter suas caracter√≠sticas pr√≥prias:</p>

<ul>
  <li>roda na <a href="http://en.wikipedia.org/wiki/Java_virtual_machine">JVM</a> <sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>;</li>
  <li>foco na imutabilidade;</li>
  <li>primitivas de concorr√™ncia/paralelismo poderosas;</li>
  <li>criada por <a href="https://twitter.com/richhickey">Rich Hickey</a> (isso parece ser uma <em>feature</em> tamb√©m).</li>
</ul>

<p><em>Nossa, quanta coisa legal!  Mas o que significa isso tudo mesmo?</em></p>

<p>Boa pergunta, curioso leitor. Pretendo respond√™-la neste e em outros posts
futuros, mas primeiro vamos ver com o que ela se parece.</p>

<h2 id="primeiro-contato">Primeiro contato</h2>

<p>N√£o poderia fazer um artigo introduzindo uma linguagem de programa√ß√£o sem o
cl√°ssico <em>hello world</em>, certo? Pois aqui vai ele:</p>

<div class="highlight"><pre><code class="language-clojure"><span class="p">(</span><span class="nb">println </span><span class="s">&quot;Hello, world&quot;</span><span class="p">)</span></code></pre></div>

<p>Nada mal, hein?  <code class="highlight language-clojure"><span class="nv">println</span></code> √© uma fun√ß√£o que recebe como
par√¢metro a string <code class="highlight language-clojure"><span class="s">&quot;Hello world&quot;</span></code>. Tirando o posicionamento
estranho dos par√™nteses, parece-se muito com a maioria das linguagens de script
por a√≠.</p>

<p>E √© exatamente esta utiliza√ß√£o dos par√™nteses que reflete as origens da
linguagem. <em>Lisp</em> vem de <em><strong>LIS</strong>t <strong>P</strong>rocessing</em>, ou Processamento de Listas.
Uma lista √© uma estrutura de dados similar aos conhecidos <em>Arrays</em> de outras
linguagens.</p>

<div class="highlight"><pre><code class="language-javascript"><span class="c1">// JavaScript</span>
<span class="p">[</span><span class="s2">&quot;Dexter Morgan&quot;</span><span class="p">,</span> <span class="s2">&quot;Hannibal Lecter&quot;</span><span class="p">,</span> <span class="s2">&quot;Patrick Bateman&quot;</span><span class="p">]</span></code></pre></div>

<p>Troque os colchetes por par√™nteses e remova as v√≠rgulas ‚Äî ou n√£o, v√≠rgulas
s√£o consideradas <em>whitespace</em> em Clojure ‚Äî e voc√™ ter√° uma lista.</p>

<div class="highlight"><pre><code class="language-clojure"><span class="c1">;; Essas duas listas s√£o equivalentes</span>
<span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;Dexter Morgan&quot;</span> <span class="s">&quot;Hannibal Lecter&quot;</span> <span class="s">&quot;Patrick Bateman&quot;</span><span class="p">)</span>
<span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;Dexter Morgan&quot;</span>, <span class="s">&quot;Hannibal Lecter&quot;</span>, <span class="s">&quot;Patrick Bateman&quot;</span><span class="p">)</span>
<span class="c1">;; Os ap√≥strofos na frente das listas precisam estar l√°.</span>
<span class="c1">;; Voc√™ entender√° o porqu√™.</span>
<span class="c1">;; √Ä prop√≥sito, ; serve para iniciar um coment√°rio que se</span>
<span class="c1">;; estende at√© o fim da linha</span></code></pre></div>

<p><em>Mas espera a√≠? O exemplo do <strong>hello world</strong> se parece muito com isso, n√£o √©?</em>
Pergunta o intrigado leitor. Continue assim, leitor. Voc√™ est√° indo bem.</p>

<figure><img src="/imgs/lists-everywhere.jpg" alt="Listas. Listas por toda parte" /><figcaption>Listas. Listas por toda parte</figcaption></figure>

<p>A√≠ est√° a beleza da coisa. Em Clojure (e em todo <em>Lisp</em>) utilizamos listas para
escrever c√≥digo. O que acontece √© que ao avaliar uma lista o primeiro elemento
deve ser uma <em>fun√ß√£o</em> (ou, como nesse caso, um nome associado a uma fun√ß√£o) e os
outros elementos ser√£o os argumentos dela. Essa √© a causa dos ap√≥strofos no
in√≠cio das listas de nomes acima. O primeiro elemento, uma <em>string</em>, n√£o pode
ser executado como uma fun√ß√£o, ent√£o precisamos indicar que esta trata-se apenas
de uma lista de valores. Mais exemplos:</p>

<div class="highlight"><pre><code class="language-clojure"><span class="p">(</span><span class="nb">+ </span><span class="mi">40</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">; =&gt; 42</span>
<span class="p">(</span><span class="nb">- </span><span class="mi">9</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">; =&gt; 5</span></code></pre></div>

<p><em>OK. Isso √© estranho!</em></p>

<p>Sim, √† primeira vista √© estranho mesmo, mas voc√™ se acostuma r√°pido. A sintaxe
dos <em>Lisps</em> √© muito simples: todas as opera√ß√µes s√£o feitas utilizando-se fun√ß√µes
atrav√©s da avalia√ß√£o de listas<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup>. No exemplo acima, o <code class="highlight language-clojure"><span class="nv">+</span></code>
e o <code class="highlight language-clojure"><span class="nv">-</span></code> n√£o s√£o operadores especiais com sintaxe especial,
como em outras linguagens. S√£o apenas fun√ß√µes inclu√≠das na biblioteca padr√£o da
linguagem inteligentemente nomeadas para, adivinhe, somar e subtrair,
respectivamente.</p>

<p>Essa sintaxe √∫nica traz algumas vantagens al√©m da √≥bvia de ser f√°cil de
memorizar:</p>

<ul>
  <li>
    <p>√â poss√≠vel ter mais que 2 operandos em cada opera√ß√£o.</p>

    <div class="highlight"><pre><code class="language-clojure"> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">;; =&gt; 15</span>
 <span class="c1">;; o mesmo que 1 + 2 + 3 + 4 + 5 em outras linguagens</span>
 <span class="p">(</span><span class="nb">&lt; </span><span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> <span class="nv">w</span><span class="p">)</span>
 <span class="c1">;; em outras linguagens: (x &lt; y) and (y &lt; z) and (z &lt; w)</span></code></pre></div>
  </li>
  <li>
    <p>N√£o √© preciso decorar tabelas de preced√™ncias, uma vez que todas as express√µes
s√£o bem delimitadas e sem riscos de ambiguidade.</p>

    <div class="highlight"><pre><code class="language-javascript"> <span class="c1">// JavaScript</span>
 <span class="mi">4</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">10</span> <span class="c1">// = 30</span>
 <span class="mi">10</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">*</span> <span class="mi">4</span> <span class="c1">// = 30.</span>
 <span class="c1">// talvez n√£o o que se espere lendo da esquerda pra direita</span>
 <span class="p">(</span><span class="mi">10</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span> <span class="c1">// = 60.</span>
 <span class="c1">// precisamos delimitar a soma pra que ela ocorra primeiro</span></code></pre></div>

    <div class="highlight"><pre><code class="language-clojure"> <span class="c1">;; Clojure</span>
 <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">+ </span><span class="mi">10</span> <span class="mi">5</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">; n√£o h√° como ser amb√≠guo aqui ...</span>
 <span class="p">(</span><span class="nb">* </span><span class="mi">4</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">10</span> <span class="mi">5</span><span class="p">))</span> <span class="c1">; ... mesmo trocando a ordem dos par√¢metros</span></code></pre></div>
  </li>
  <li>
    <p>Listas s√£o usadas para escrever o c√≥digo<sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup> e, ao mesmo tempo, s√£o as estruturas
de dados utilizadas para representar o programa em tempo de execu√ß√£o. Este
paralelo entre sintaxe e a estrutura interna do programa, que chamamos de
<strong>homoiconicidade</strong>, permite que c√≥digo seja criado e manipulado como <em>dados</em>.
Linguagens homoic√¥nicas facilitam a metaprograma√ß√£o e reflex√£o (temas para um
outro <em>post</em>).</p>
  </li>
</ul>

<p>Nem tudo √© vantagem. Essa sintaxe, em alguns casos, tende a acumular par√™nteses
amontoados no final de grandes express√µes, embora existam formas de contornar
isso. Tamb√©m √© preciso um pouco de pr√°tica at√© se conseguir ler claramente o
c√≥digo escrito por outras pessoas (pelo menos foi o meu caso).</p>

<p>Sem d√∫vidas, os par√™nteses s√£o os principais motivos de programadores
iniciantes (eu incluso) torcerem o nariz ao se deparar com <em>Lisp</em>, mas n√£o tema.
Qualquer bom editor vai te ajudar com isso.</p>

<h2 id="read-eval-print-loop"><em>read-eval-print loop</em></h2>

<p>Antes de continuar a descrever a linguagem, deixa eu explicar como colocar as
m√£os no compilador e testar os c√≥digos voc√™ mesmo.</p>

<p>Voc√™ pode obter a vers√£o est√°vel mais recente do compilador <a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.7.0/clojure-1.7.0.zip">aqui</a>.
Como eu disse, Clojure utiliza a <em>Java Virtual Machine</em> para executar seus
programas. Este <em>zip</em> cont√©m, entre outras coisas, o arquivo
<code>clojure-1.7.0.jar</code>, que possui tudo o que √© necess√°rio para compilar, executar
e testar os seus programas (considerando que voc√™ j√° tem a JVM instalada, caso
contr√°rio, v√° <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">aqui</a> primeiro).</p>

<p>Para os n√£o-iniciados no universo <em>javistico</em>, um <em>JAR</em> √© um pacote pelo qual se
distribui um execut√°vel ou biblioteca. Algo parecido com as <em>gems</em> do <em>Ruby</em>,
<em>eggs</em> do <em>Python</em> ou os <em>crates</em> do <em>Rust</em>. Existem outras formas de obter e
gerenciar depend√™ncias Java/Clojure (<em>Maven</em>, <em>Leiningem</em>, <em>Boot</em>, etc), mas por
enquanto s√≥ o download √© suficiente.</p>

<p>Num terminal, execute o seguinte comando no mesmo diret√≥rio onde est√° o arquivo
<code>clojure-1.7.0.jar</code> que voc√™ extraiu do <em>zip</em> baixado:</p>

<div class="highlight"><pre><code class="language-bash">java -cp clojure-1.7.0.jar clojure.main</code></pre></div>

<figure><img src="/imgs/repl.png" alt="Bem-vindo ao REPL" /><figcaption>Bem-vindo ao REPL</figcaption></figure>

<p>O <em>prompt</em> que aparece, aguardando que algo seja digitado, √© parte do <strong>REPL</strong>,
ou <em>Read-Print-Eval Loop</em>, uma ferramenta distribu√≠da junto com o compilador
que permite a execu√ß√£o interativa de c√≥digo. Ele <em>l√™</em> o comando digitado,
<em>avalia</em> e executa as express√µes, <em>imprime</em> o resultado e <em>volta</em> a esperar
outro comando. <em>REPLs</em> n√£o s√£o exclusividades dos Lisps, mas costumam integrar
o <em>workflow</em> dos programadores dessas linguagens mais que os outros. Vamos
tentar uma das express√µes que j√° mostrei: digite <code class="highlight language-clojure"><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span></code>
e tecle <em>enter</em>.</p>

<figure><img src="/imgs/repl-ex1.png" alt="Exemplo 1: uma calculadora bem incomum" /><figcaption>Exemplo 1: uma calculadora bem incomum</figcaption></figure>

<p>Express√£o lida (<em>read</em>), avaliada/executada (<em>eval</em>), resultado impresso
(<em>print</em>) e prompt esperando uma nova express√£o (<em>loop</em>). Tente usar outras
fun√ß√µes matem√°ticas (<code class="highlight language-clojure"><span class="nv">+</span></code>, <code class="highlight language-clojure"><span class="nv">-</span></code>,
<code class="highlight language-clojure"><span class="nv">/</span></code>, <code class="highlight language-clojure"><span class="nv">*</span></code>), l√≥gicas
(<code class="highlight language-clojure"><span class="nv">&gt;</span></code>, <code class="highlight language-clojure"><span class="nv">&lt;</span></code>, <code class="highlight language-clojure"><span class="nv">&gt;=</span></code>,
<code class="highlight language-clojure"><span class="nv">&lt;=</span></code>), de entrada de dados (<code class="highlight language-clojure"><span class="nv">read-line</span></code>)
e de sa√≠da (<code class="highlight language-clojure"><span class="nv">print</span></code>, <code class="highlight language-clojure"><span class="nv">println</span></code>). Para
interromper o REPL, pressione <code>Control+C</code> ou <code>Control+D</code>.</p>

<h2 id="formas-especiais">Formas especiais</h2>

<p>De volta ao conte√∫do principal. Agora que j√° entendemos a ideia de listas serem
avaliadas como chamadas de fun√ß√µes, podemos escrever qualquer tipo de programa
em Clojure, certo? Bem, nem tanto.</p>

<p>Mais cedo do que voc√™ pensa seu programa precisar√° de mais poderes, como decidir
se precisa ou n√£o executar certa fun√ß√£o ou repetir uma execu√ß√£o v√°rias vezes.
Para tal, existem <strong>formas<sup id="fnref:4"><a href="#fn:4" class="footnote">4</a></sup> especiais</strong> que alteram a maneira como
o compilador/interpretador avalia as express√µes lidas. N√£o irei descrever todas
aqui hoje (n√£o s√£o muitas), s√≥ o necess√°rio para come√ßar.</p>

<h3 id="if">if</h3>

<div class="highlight"><pre><code class="language-clojure"><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="s">&quot;Yea!&quot;</span> <span class="s">&quot;Nay!&quot;</span><span class="p">)</span>
<span class="c1">;; = √© a fun√ß√£o usada para comparar valores, equivalente ao</span>
<span class="c1">;; operador == da maioria das outras linguagens</span></code></pre></div>

<p>O <strong>if</strong> √© a forma usada para avalia√ß√£o condicional de express√µes. Ele tem a
mesma cara das outras fun√ß√µes mostradas at√© agora, n√©? Essa √© a ideia. √â uma
lista com 4 elementos, o que poder ser entendido como uma fun√ß√£o que recebe 3
argumentos. Por√©m, diferente de outras listas, nem todos os seus elementos
ser√£o avaliados.</p>

<p>Se o resultado da avalia√ß√£o do primeiro argumento for <em>verdadeiro</em><sup id="fnref:5"><a href="#fn:5" class="footnote">5</a></sup> o valor
da forma como um todo ser√° o resultado da avalia√ß√£o do segundo argumento
e o terceiro argumento nunca ser√° avaliado. Se o primeiro argumento for algo que
indique falsidade ocorrer√° o inverso. O interpretador ir√° ignorar o segundo
argumento e avaliar o terceiro. Em Ruby seria algo assim:</p>

<div class="highlight"><pre><code class="language-ruby"><span class="k">if</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span>
  <span class="s2">&quot;Yea!&quot;</span>
<span class="k">else</span>
  <span class="s2">&quot;Nay!&quot;</span>
<span class="k">end</span></code></pre></div>

<h3 id="let">let</h3>

<p>A essa altura voc√™ j√° est√° se perguntando porque n√£o declarei nenhuma vari√°vel
nos exemplos mostrados. √â que tem uma pegadinha aqui. Em Clojure voc√™ n√£o
<em>atribui valores</em> a vari√°veis como voc√™ pode estar acostumado. Voc√™ <em>associa um
valor</em> a um nome. N√£o parece, mas tem uma diferen√ßa. Em <em>C</em>, por exemplo, voc√™
pode atribuir novos valores a uma vari√°vel pr√©-existente:</p>

<div class="highlight"><pre><code class="language-C"><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">number</span><span class="p">,</span> <span class="n">number</span><span class="p">);</span>
  <span class="n">number</span> <span class="o">=</span> <span class="mi">9999</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">number</span><span class="p">,</span> <span class="n">number</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// a sa√≠da seria algo como:</span>
<span class="c1">// 0x7fff5717e648: 0</span>
<span class="c1">// 0x7fff5717e648: 9999</span></code></pre></div>

<p>Nesse exemplo d√° pra ver que a vari√°vel <code class="highlight language-c"><span class="n">number</span></code> √© uma refer√™ncia
sempre √† posi√ß√£o da mem√≥ria <code>0x7fff5717e648</code>, mesmo depois de mudarmos o valor.
Caso duas <em>threads</em> estivessem lendo e/ou alterando essa vari√°vel
o comportamento seria imprevis√≠vel.</p>

<p>Clojure evita esse problema impedindo ‚Äî ou pelo menos dificultando ‚Äî que voc√™
altere o valor de vari√°veis. Voc√™ cria associa√ß√µes, ou <em>bindings</em>, entre nomes e
valores para um escopo. Isso √© feito usando a forma especial <strong>let</strong>.</p>

<div class="highlight"><pre><code class="language-clojure"><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">a</span> <span class="mi">10</span>
      <span class="nv">b</span> <span class="mi">20</span>
      <span class="nv">c</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)]</span> <span class="c1">;; cada binding tem acesso aos bindings anteriores</span>
  <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)))</span>
<span class="c1">;; =&gt; 60</span></code></pre></div>

<p>Dois (ou mais) argumentos s√£o passados para o <code class="highlight language-clojure"><span class="nv">let</span></code>. Um
<em>vetor</em><sup id="fnref:6"><a href="#fn:6" class="footnote">6</a></sup> de <em>bindings</em>, composto de pares s√≠mbolo/valor, e um <em>corpo</em>, que
√© o conjunto de express√µes que forma o escopo no qual os s√≠mbolos estar√£o
associados aos valores mencionados. O resultado da √∫ltima express√£o do corpo
ser√° o valor do <code class="highlight language-clojure"><span class="nv">let</span></code> como um todo.</p>

<h3 id="def">def</h3>

<p>Eu meio que <em>menti</em> quando disse que a √∫nica forma de dar nomes √† valores
√© atrav√©s de <code class="highlight language-clojure"><span class="nv">let</span></code>. Voc√™ vai precisar dar nomes √† dados que
viver√£o por todo o tempo de execu√ß√£o de um programa e n√£o um pequeno escopo.
Imagine as fun√ß√µes que voc√™ define, por exemplo, ou valores que s√£o considerados
<em>constantes</em>.</p>

<p>Para <strong>definir</strong> esses nomes existe a forma especial <strong>def</strong>. Nome bem √≥bvio,
n√©? Ela √© usada da seguinte maneira:</p>

<div class="highlight"><pre><code class="language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">pi</span> <span class="mf">3.14</span><span class="p">)</span> <span class="c1">;; um valor muito pouco preciso de ùõë</span>
<span class="c1">;; =&gt; #&#39;user/pi [I]</span>
<span class="nv">pi</span>
<span class="c1">;; =&gt; 3.14 [II]</span>
<span class="p">(</span><span class="k">def </span><span class="nv">three-pi-over-two</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">* </span><span class="mi">3</span> <span class="nv">pi</span><span class="p">)</span> <span class="mi">2</span><span class="p">))</span>
<span class="c1">;; =&gt; #&#39;user/three-pi-over-two [III]</span>
<span class="nv">three-pi-over-two</span>
<span class="c1">;; =&gt; 4.71 [IV]</span></code></pre></div>

<p>Sem mist√©rio. Uma lista de tr√™s elementos: o s√≠mbolo <code>def</code>, um s√≠mbolo que
representa o nome da vari√°vel <strong>global</strong> sendo criada e uma express√£o que ser√°
avaliada e o seu resultado atribu√≠do √† vari√°vel. Observe que o <code>def</code> retorna
a vari√°vel em si (indicado pelos caracteres <code>#'</code><sup id="fnref:7"><a href="#fn:7" class="footnote">7</a></sup> em <code>[I]</code> e <code>[III]</code>) e n√£o
o seu valor. Observe tamb√©m que os nomes das vari√°veis retornadas s√£o iniciados
por <code>user/</code>. Esse √© o nome do <strong>namespace</strong> no qual ela foi definida.
<em>Namespaces</em> s√£o utilizados para agrupar fun√ß√µes relacionadas e evitar conflitos
de nomes de vari√°veis. Mais sobre <em>namespaces</em> em outra oportunidade. </p>

<p>Depois das defini√ß√µes, quaisquer utiliza√ß√µes dos s√≠mbolos usados resulta na
avalia√ß√£o do mesmo como o valor armazenado na vari√°vel correspondente, como pode
ser visto em <code>[II]</code> e <code>[IV]</code>.</p>

<h3 id="fn">fn</h3>

<p>Como n√£o poderia deixa de ser numa linguagem <strong>funcional</strong>, √© preciso existir
uma forma de definir fun√ß√µes. Isso √© trabalho do <strong>fn</strong> (Clojure tem uma
filosofia de que se uma fun√ß√£o ou macro ser√° muito utilizada ele deve ter um
nome bem curto, por isso, <code class="highlight language-clojure"><span class="nv">fn</span></code> e n√£o <code>function</code>, por
exemplo).</p>

<div class="highlight"><pre><code class="language-clojure"><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">name</span><span class="p">]</span> <span class="p">(</span><span class="nb">str </span><span class="s">&quot;Hello, &quot;</span> <span class="nv">name</span><span class="p">))</span>
<span class="c1">;; =&gt; #object[user$eval1$fn__2 0x465232e9 &quot;user$eval1$fn__2@465232e9&quot;]</span></code></pre></div>

<p>Ao entrar a express√£o acima no REPL ele devolver√° algo bem estranho como
mostrado acima. N√£o se preocupe com isso. <code>fn</code> retorna uma fun√ß√£o e o REPL tenta
imprimi-la. Essa √© a representa√ß√£o interna dela e n√£o √© muito √∫til para n√≥s.</p>

<p>Nenhuma novidade na sintaxe. De novo temos uma lista, agora com 3 (ou mais)
elementos. O segundo √© um vetor de <em>bindings</em>, semelhante ao do
<code class="highlight language-clojure"><span class="nv">let</span></code>, mas sem os valores. Esses valores s√≥ ser√£o informados
quando executarmos a fun√ß√£o. √Ä partir do terceiro elemento temos o corpo da
fun√ß√£o. Tamb√©m como no <code class="highlight language-clojure"><span class="nv">let</span></code>, o corpo comp√µe o escopo onde
os <em>bindings</em> estar√£o acess√≠veis e o valor da avalia√ß√£o da √∫ltima express√£o do
corpo ser√° o valor de retorno da fun√ß√£o. No entanto, esse corpo n√£o √© executado
de imediado, apenas quando a fun√ß√£o for ‚Äúchamada‚Äù.</p>

<p><em>S√≥ tem um problema, como eu chamo essa fun√ß√£o?</em> Mais uma vez surpreende o
antenado leitor fazendo a pergunta certa.</p>

<p>J√° sabemos que uma fun√ß√£o ser√° avaliada quando for o primeiro elemento de uma
lista, ent√£o podemos fazer isso:</p>

<div class="highlight"><pre><code class="language-clojure"><span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">name</span><span class="p">]</span> <span class="p">(</span><span class="nb">str </span><span class="s">&quot;Hello, &quot;</span> <span class="nv">name</span><span class="p">))</span> <span class="s">&quot;Dexter&quot;</span><span class="p">)</span>
<span class="c1">;; =&gt; &quot;Hello, Dexter&quot;</span>
<span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">name</span><span class="p">]</span> <span class="p">(</span><span class="nb">str </span><span class="s">&quot;Hello, &quot;</span> <span class="nv">name</span><span class="p">))</span> <span class="s">&quot;Jack&quot;</span><span class="p">)</span>
<span class="c1">;; =&gt; &quot;Hello, Jack&quot;</span></code></pre></div>

<p>Mas isso n√£o √© muito pr√°tico nem reus√°vel, afinal nas duas execu√ß√µes duas
c√≥pias distintas da fun√ß√£o s√£o criadas. Sem falar que seria loucura ficar
copiando fun√ß√µes de uma lado pro outro. Podemos fazer melhor. E se voc√™ est√°
mesmo acompanhando o post ‚Äî ou j√° programou em JavaScript<sup id="fnref:8"><a href="#fn:8" class="footnote">8</a></sup> ‚Äî sabe muito
bem o que fazer:</p>

<div class="highlight"><pre><code class="language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">greet</span>
  <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">name</span><span class="p">]</span> <span class="p">(</span><span class="nb">str </span><span class="s">&quot;Hello, &quot;</span> <span class="nv">name</span><span class="p">)))</span>
<span class="c1">;; =&gt; #&#39;user/greet</span>
<span class="p">(</span><span class="nf">greet</span> <span class="s">&quot;Dexter&quot;</span><span class="p">)</span>
<span class="c1">;; =&gt; &quot;Hello, Dexter&quot;</span>
<span class="p">(</span><span class="nf">greet</span> <span class="s">&quot;Jack&quot;</span><span class="p">)</span>
<span class="c1">;; =&gt; &quot;Hello, Jack&quot;</span></code></pre></div>

<p>Lembra da <em>homoiconicidade</em>? C√≥digo √© dado, e como tal pode ser associado
a nomes como qualquer outro tipo. E a necessidade de se atribuir nomes a fun√ß√µes
√© t√£o comum que existe uma forma ainda mais pr√°tica de se fazer isso:</p>

<div class="highlight"><pre><code class="language-clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">greet</span> <span class="p">[</span><span class="nv">name</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">str </span><span class="s">&quot;Hello, &quot;</span> <span class="nv">name</span><span class="p">))</span>
<span class="c1">;; =&gt; #&#39;user/greet</span></code></pre></div>

<p>Compare com o exemplo anterior. A cria√ß√£o da fun√ß√£o, com
<code class="highlight language-clojure"><span class="nv">fn</span></code>, e a atribui√ß√£o do nome, com <code class="highlight language-clojure"><span class="nv">def</span></code>,
podem ser reduzidas para apenas um passo com a macro <code class="highlight language-clojure"><span class="nv">defn</span></code>.</p>

<h2 id="cenas-dos-prximos-captulos">Cenas dos pr√≥ximos cap√≠tulos</h2>

<p>Se voc√™ chegou at√© aqui, acredito que esteja realmente interessado em Clojure
e espero que minhas explica√ß√µes tenham sido claras o suficiente (se n√£o foram,
fique √† vontade para pedir esclarecimentos e deixar sugest√µes nos coment√°rios).</p>

<p>Este <em>post</em> n√£o chegou nem a arranhar a superf√≠cie da linguagem, por√©m j√° ficou
grande o bastante para darmos por encerrado o dia de trabalho. Mas n√£o sem antes
deixar registrado o que vem por ai (sem pretens√£o de fazer uma lista exaustiva
nem definir alguma ordem ou periodicidade):</p>

<ul>
  <li>listas, vetores, conjuntos e mapas;</li>
  <li>loops e recursividade;</li>
  <li>organizando c√≥digo em <em>namespaces</em>;</li>
  <li>fazendo as coisas do jeito funcional;</li>
  <li>trabalhando com imutabilidade;</li>
  <li>paralelismo e concorr√™ncia;</li>
  <li>Clojure(Script) conversando com o mundo Java(Script);</li>
  <li>macros: c√≥digo que manipula c√≥digo;</li>
  <li>desenvolvimento web com Clojure;</li>
  <li>ferramentas de <em>build</em>: <code>leiningen</code> e <code>boot</code>;</li>
  <li>como escrever testes;</li>
  <li>Single Page Applications com ClojureScript (e React?);</li>
  <li>sua sugest√£o.</li>
</ul>

<p>At√© breve (espero).</p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>Existem tamb√©m implementa√ß√µes que compilam para a <a href="http://github.com/clojure/clojure-clr">CLR</a> e para <a href="http://github.com/clojure/clojurescript">JavaScript</a>. <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>Nem sempre o primeiro elemento √© uma fun√ß√£o. Existem tamb√©m <em>macros</em> e <em>formas especiais</em>, mas a sintaxe n√£o muda. Podemos generalizar e dizer que tudo s√£o fun√ß√µes. <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>Tradicionalmente Lisps usam apenas listas para representar c√≥digo. Clojure usa outras estruturas, como <em>vetores</em> e <em>mapas</em>. <a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p>Uma forma √© qualquer coisa que possa avaliada. Existe uma s√∫til diferen√ßa entre <em>formas</em> e <em>express√µes</em>, mas para todos os efeitos podemos usas as duas palavras indistintamente. <a href="#fnref:4" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:5">
      <p>Quaisquer valores diferentes de <code>nil</code> e <code>false</code> ser√£o considerados verdadeiros numa avalia√ß√£o l√≥gica. √â o comportamento j√° conhecido por programadores Ruby. Em C <code>0</code> √© considerado falso, em Clojure n√£o. Assim como listas vazias <code>'()</code>, que tamb√©m indicam falsidade em outros Lisps e indicam verdade em Clojure. <a href="#fnref:5" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:6">
      <p>Mais sobre vetores em outra oportunidade. Por enquanto basta saber que s√£o como listas, mas tem colchetes <code>[]</code>, no lugar dos par√™nteses <code>()</code>. <a href="#fnref:6" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:7">
      <p><code>#'</code> √© um exemplo de uma <em>macro de leitura</em>. Simplesmente uma forma mais sucinta de executar alguma fun√ß√£o. Nesse caso <code>#'user/pi</code> equivale a <code>(var user/pi)</code>. Existem v√°rias outras macros de leitura, que devem ser exploradas em <em>posts</em> mais apropriados. <a href="#fnref:7" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:8">
      <p>√â muito comum em JavaScript associarmos fun√ß√µes sem nome a vari√°veis: <code class="highlight language-javascript"><span class="kd">var</span> <span class="nx">greet</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="s2">&quot;Hello, &quot;</span> <span class="o">+</span> <span class="nx">name</span><span class="p">;</span> <span class="p">}</span></code> <a href="#fnref:8" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

</article>
<div class="so_comments" data-sitename="sparse-thoughts" data-thread_url="/comecando-com-clojure"></div>
<script src="//api.solidopinion.com/widget/embed.js" async="async"></script>

    <footer>
    Samuel Flores
    ‚Ä¢ <a href="http://github.com/samflores">Github</a>
    ‚Ä¢ <a href="http://twitter.com/samflores">Twitter</a>
</footer>

    <script src="/js/ffo.js"></script>
<script>
(function(i,s,o,g,r,a,m){
    i['GoogleAnalyticsObject']=r;
    i[r] = i[r] || function(){
        (i[r].q = i[r].q||[]).push(arguments)
    },
    i[r].l = 1*new Date();
    a = s.createElement(o),
    m = s.getElementsByTagName(o)[0];
    a.async=1;
    a.src=g;
    m.parentNode.insertBefore(a,m)
}(window,document,'script','//www.google-analytics.com/analytics.js','ga'));

ga('create', 'UA-46715735-2', 'auto');
ga('send', 'pageview');

(function(w,d,p,f,c,q,e){
    o=function(s){
        q=d.querySelectorAll(s);
        for(e=0;e<q.length;e++){q[e].classList.add('ok')}
    }
    f=function(t,s){
        new w.FontFaceObserver(t,{}).check(null, 3000).then(o(s));
    }
    for(var t in p){f(t,p[t]);}
}(window,document,{
    "Goudy Bookletter 1911": "body",
    "Anonymous Pro": "pre"
}));
</script>

</body>

</html>
